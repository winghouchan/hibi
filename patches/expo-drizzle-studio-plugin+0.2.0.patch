# Adds support for OP SQLite.

diff --git a/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.d.ts b/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.d.ts
index eb16d8d..56e777b 100644
--- a/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.d.ts
+++ b/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.d.ts
@@ -1,3 +1,12 @@
-import * as SQLite from 'expo-sqlite';
-export declare function useDrizzleStudio(db: SQLite.SQLiteDatabase | null): void;
+import * as SQLite from "expo-sqlite";
+import { DB } from "@op-engineering/op-sqlite";
+type Config = {
+    driver: "expo";
+    db: SQLite.SQLiteDatabase | null;
+} | {
+    driver: "opsqlite";
+    db: DB | null;
+};
+export declare function useDrizzleStudio({ driver, db }: Config): void;
+export {};
 //# sourceMappingURL=useDrizzleStudio.d.ts.map
\ No newline at end of file
diff --git a/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.d.ts.map b/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.d.ts.map
index 204dd53..c83bf38 100644
--- a/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.d.ts.map
+++ b/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"useDrizzleStudio.d.ts","sourceRoot":"","sources":["../src/useDrizzleStudio.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,MAAM,aAAa,CAAC;AAItC,wBAAgB,gBAAgB,CAAC,EAAE,EAAE,MAAM,CAAC,cAAc,GAAG,IAAI,QAwDhE"}
\ No newline at end of file
+{"version":3,"file":"useDrizzleStudio.d.ts","sourceRoot":"","sources":["../src/useDrizzleStudio.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,MAAM,aAAa,CAAC;AACtC,OAAO,EAAE,EAAE,EAAE,MAAM,2BAA2B,CAAC;AAQ/C,KAAK,MAAM,GACP;IACE,MAAM,EAAE,MAAM,CAAC;IACf,EAAE,EAAE,MAAM,CAAC,cAAc,GAAG,IAAI,CAAC;CAClC,GACD;IACE,MAAM,EAAE,UAAU,CAAC;IACnB,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC;CACf,CAAC;AAaN,wBAAgB,gBAAgB,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,MAAM,QAmGtD"}
\ No newline at end of file
diff --git a/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.js b/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.js
index eb0959c..5fdc035 100644
--- a/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.js
+++ b/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.js
@@ -1,48 +1,80 @@
-import { useDevToolsPluginClient } from 'expo/devtools';
-import { useEffect } from 'react';
-export function useDrizzleStudio(db) {
-    const client = useDevToolsPluginClient('expo-drizzle-studio-plugin');
-    const queryFn = (db, client) => async (e) => {
+import { useDevToolsPluginClient, } from "expo/devtools";
+import { useEffect } from "react";
+function isExpo(driver, db) {
+    return driver === "expo";
+}
+function isOPSQLite(driver, db) {
+    return driver === "opsqlite";
+}
+export function useDrizzleStudio({ driver, db }) {
+    const client = useDevToolsPluginClient("expo-drizzle-studio-plugin");
+    const queryFn = (db, client) => async ({ arrayMode, id, params, sql, }) => {
+        let data = [];
         try {
-            const statement = await db.prepareAsync(e.sql);
-            let executed;
-            if (e.arrayMode) {
-                executed = await statement.executeForRawResultAsync(e.params || []);
+            if (isExpo(driver, db)) {
+                const statement = await db.prepareAsync(sql);
+                let executed;
+                if (arrayMode) {
+                    executed = await statement.executeForRawResultAsync(params || []);
+                }
+                else {
+                    executed = await statement.executeAsync(params || []);
+                }
+                data = await executed.getAllAsync();
             }
-            else {
-                executed = await statement.executeAsync(e.params || []);
+            else if (isOPSQLite(driver, db)) {
+                if (arrayMode) {
+                    data = await db.executeRaw(sql, params);
+                }
+                else {
+                    const statement = db.prepareStatement(sql);
+                    if (params) {
+                        statement.bind(params);
+                    }
+                    const executed = await statement.execute();
+                    data = executed.rows;
+                }
             }
-            const data = await executed.getAllAsync();
-            client.sendMessage(`query-${e.id}`, data);
+            client.sendMessage(`query-${id}`, data);
         }
         catch (error) {
-            client.sendMessage(`query-${e.id}`, { error: error.message });
+            client.sendMessage(`query-${id}`, { error: error.message });
         }
     };
-    const transactionFn = (db, client) => async (e) => {
+    const transactionFn = (db, client) => async ({ id, queries, }) => {
         const results = [];
         try {
-            await db.withTransactionAsync(async () => {
-                for (const query of e.queries) {
-                    const stmt = await db.prepareAsync(query.sql);
-                    const executed = await stmt.executeAsync(query.params || []);
-                    const result = await executed.getAllAsync();
-                    results.push(result);
-                }
-            });
+            if (isExpo(driver, db)) {
+                await db.withTransactionAsync(async () => {
+                    for (const query of queries) {
+                        const stmt = await db.prepareAsync(query.sql);
+                        const executed = await stmt.executeAsync(query.params || []);
+                        const result = await executed.getAllAsync();
+                        results.push(result);
+                    }
+                });
+            }
+            else if (isOPSQLite(driver, db)) {
+                await db.transaction(async (transaction) => {
+                    for (const { sql, params } of queries) {
+                        const executed = await transaction.execute(sql, params);
+                        results.concat(executed.rows);
+                    }
+                });
+            }
         }
         catch (error) {
             results.push({ error: error.message });
         }
-        client.sendMessage(`transaction-${e.id}`, results);
+        client.sendMessage(`transaction-${id}`, results);
     };
     useEffect(() => {
         if (!client || !db) {
             return;
         }
         const subscriptions = [];
-        subscriptions.push(client.addMessageListener('query', queryFn(db, client)));
-        subscriptions.push(client.addMessageListener('transaction', transactionFn(db, client)));
+        subscriptions.push(client.addMessageListener("query", queryFn(db, client)));
+        subscriptions.push(client.addMessageListener("transaction", transactionFn(db, client)));
         return () => {
             for (const subscription of subscriptions) {
                 subscription.remove();
diff --git a/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.js.map b/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.js.map
index 7f26770..c60766e 100644
--- a/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.js.map
+++ b/node_modules/expo-drizzle-studio-plugin/build/useDrizzleStudio.js.map
@@ -1 +1 @@
-{"version":3,"file":"useDrizzleStudio.js","sourceRoot":"","sources":["../src/useDrizzleStudio.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as SQLite from 'expo-sqlite';\nimport { DevToolsPluginClient, EventSubscription, useDevToolsPluginClient } from 'expo/devtools';\nimport { useEffect } from 'react';\n\nexport function useDrizzleStudio(db: SQLite.SQLiteDatabase | null) {\n  const client = useDevToolsPluginClient('expo-drizzle-studio-plugin');\n\n  const queryFn =\n    (db: SQLite.SQLiteDatabase, client: DevToolsPluginClient) =>\n    async (e: { sql: string; params?: SQLite.SQLiteBindValue[]; arrayMode: boolean; id: string }) => {\n      try {\n        const statement = await db.prepareAsync(e.sql);\n        let executed: SQLite.SQLiteExecuteAsyncResult<unknown>;\n        if (e.arrayMode) {\n          executed = await statement.executeForRawResultAsync(e.params || []);\n        } else {\n          executed = await statement.executeAsync(e.params || []);\n        }\n        const data = await executed.getAllAsync();\n        client.sendMessage(`query-${e.id}`, data);\n      } catch (error) {\n        client.sendMessage(`query-${e.id}`, { error: error.message });\n      }\n    };\n\n  const transactionFn =\n    (db: SQLite.SQLiteDatabase, client: DevToolsPluginClient) =>\n    async (e: { queries: { sql: string; params?: SQLite.SQLiteBindValue[] }[]; id: string }) => {\n      const results: any[] = [];\n      try {\n        await db.withTransactionAsync(async () => {\n          for (const query of e.queries) {\n            const stmt = await db.prepareAsync(query.sql);\n            const executed = await stmt.executeAsync(query.params || []);\n            const result = await executed.getAllAsync();\n            results.push(result);\n          }\n        });\n      } catch (error) {\n        results.push({ error: error.message });\n      }\n      client.sendMessage(`transaction-${e.id}`, results);\n    };\n\n  useEffect(() => {\n    if (!client || !db) {\n      return;\n    }\n\n    const subscriptions: EventSubscription[] = [];\n\n    subscriptions.push(client.addMessageListener('query', queryFn(db, client)));\n    subscriptions.push(client.addMessageListener('transaction', transactionFn(db, client)));\n\n    return () => {\n      for (const subscription of subscriptions) {\n        subscription.remove();\n      }\n    };\n  }, [client, db]);\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"useDrizzleStudio.js","sourceRoot":"","sources":["../src/useDrizzleStudio.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as SQLite from \"expo-sqlite\";\nimport { DB } from \"@op-engineering/op-sqlite\";\nimport {\n  DevToolsPluginClient,\n  EventSubscription,\n  useDevToolsPluginClient,\n} from \"expo/devtools\";\nimport { useEffect } from \"react\";\n\ntype Config =\n  | {\n      driver: \"expo\";\n      db: SQLite.SQLiteDatabase | null;\n    }\n  | {\n      driver: \"opsqlite\";\n      db: DB | null;\n    };\n\nfunction isExpo(\n  driver: Config[\"driver\"],\n  db: Config[\"db\"]\n): db is SQLite.SQLiteDatabase {\n  return driver === \"expo\";\n}\n\nfunction isOPSQLite(driver: Config[\"driver\"], db: Config[\"db\"]): db is DB {\n  return driver === \"opsqlite\";\n}\n\nexport function useDrizzleStudio({ driver, db }: Config) {\n  const client = useDevToolsPluginClient(\"expo-drizzle-studio-plugin\");\n\n  const queryFn =\n    (db: DB | SQLite.SQLiteDatabase, client: DevToolsPluginClient) =>\n    async ({\n      arrayMode,\n      id,\n      params,\n      sql,\n    }: {\n      sql: string;\n      params?: SQLite.SQLiteBindValue[];\n      arrayMode: boolean;\n      id: string;\n    }) => {\n      let data: unknown[] = [];\n\n      try {\n        if (isExpo(driver, db)) {\n          const statement = await db.prepareAsync(sql);\n          let executed: SQLite.SQLiteExecuteAsyncResult<unknown>;\n          if (arrayMode) {\n            executed = await statement.executeForRawResultAsync(params || []);\n          } else {\n            executed = await statement.executeAsync(params || []);\n          }\n          data = await executed.getAllAsync();\n        } else if (isOPSQLite(driver, db)) {\n          if (arrayMode) {\n            data = await db.executeRaw(sql, params);\n          } else {\n            const statement = db.prepareStatement(sql);\n            if (params) {\n              statement.bind(params);\n            }\n            const executed = await statement.execute();\n            data = executed.rows;\n          }\n        }\n\n        client.sendMessage(`query-${id}`, data);\n      } catch (error) {\n        client.sendMessage(`query-${id}`, { error: error.message });\n      }\n    };\n\n  const transactionFn =\n    (db: DB | SQLite.SQLiteDatabase, client: DevToolsPluginClient) =>\n    async ({\n      id,\n      queries,\n    }: {\n      queries: { sql: string; params?: SQLite.SQLiteBindValue[] }[];\n      id: string;\n    }) => {\n      const results: any[] = [];\n      try {\n        if (isExpo(driver, db)) {\n          await db.withTransactionAsync(async () => {\n            for (const query of queries) {\n              const stmt = await db.prepareAsync(query.sql);\n              const executed = await stmt.executeAsync(query.params || []);\n              const result = await executed.getAllAsync();\n              results.push(result);\n            }\n          });\n        } else if (isOPSQLite(driver, db)) {\n          await db.transaction(async (transaction) => {\n            for (const { sql, params } of queries) {\n              const executed = await transaction.execute(sql, params);\n              results.concat(executed.rows);\n            }\n          });\n        }\n      } catch (error) {\n        results.push({ error: error.message });\n      }\n      client.sendMessage(`transaction-${id}`, results);\n    };\n\n  useEffect(() => {\n    if (!client || !db) {\n      return;\n    }\n\n    const subscriptions: EventSubscription[] = [];\n\n    subscriptions.push(client.addMessageListener(\"query\", queryFn(db, client)));\n    subscriptions.push(\n      client.addMessageListener(\"transaction\", transactionFn(db, client))\n    );\n\n    return () => {\n      for (const subscription of subscriptions) {\n        subscription.remove();\n      }\n    };\n  }, [client, db]);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-drizzle-studio-plugin/src/useDrizzleStudio.tsx b/node_modules/expo-drizzle-studio-plugin/src/useDrizzleStudio.tsx
index 6907d26..7935846 100644
--- a/node_modules/expo-drizzle-studio-plugin/src/useDrizzleStudio.tsx
+++ b/node_modules/expo-drizzle-studio-plugin/src/useDrizzleStudio.tsx
@@ -1,45 +1,100 @@
 import * as SQLite from 'expo-sqlite';
+import { DB } from '@op-engineering/op-sqlite'
 import { DevToolsPluginClient, EventSubscription, useDevToolsPluginClient } from 'expo/devtools';
 import { useEffect } from 'react';
 
-export function useDrizzleStudio(db: SQLite.SQLiteDatabase | null) {
+type Config = {
+  driver: 'expo';
+  db: SQLite.SQLiteDatabase | null;
+} | {
+  driver: 'opsqlite';
+  db: DB | null;
+};
+
+function isExpo(driver: Config['driver'], db: Config['db']): db is SQLite.SQLiteDatabase {
+  return driver === 'expo'
+}
+
+function isOPSQLite(driver: Config['driver'], db: Config['db']): db is DB {
+  return driver === 'opsqlite'
+}
+
+export function useDrizzleStudio({
+  driver,
+  db
+}: Config) {
   const client = useDevToolsPluginClient('expo-drizzle-studio-plugin');
 
   const queryFn =
-    (db: SQLite.SQLiteDatabase, client: DevToolsPluginClient) =>
-    async (e: { sql: string; params?: SQLite.SQLiteBindValue[]; arrayMode: boolean; id: string }) => {
+    (db: DB | SQLite.SQLiteDatabase, client: DevToolsPluginClient) =>
+    async ({
+      arrayMode,
+      id,
+      params,
+      sql,
+    }: {
+      sql: string;
+      params?: SQLite.SQLiteBindValue[];
+      arrayMode: boolean;
+      id: string
+    }) => {
+      let data: unknown[] = [];
+
       try {
-        const statement = await db.prepareAsync(e.sql);
-        let executed: SQLite.SQLiteExecuteAsyncResult<unknown>;
-        if (e.arrayMode) {
-          executed = await statement.executeForRawResultAsync(e.params || []);
-        } else {
-          executed = await statement.executeAsync(e.params || []);
+        if (isExpo(driver, db)) {
+          const statement = await db.prepareAsync(sql);
+          let executed: SQLite.SQLiteExecuteAsyncResult<unknown>;
+          if (arrayMode) {
+            executed = await statement.executeForRawResultAsync(params || []);
+          } else {
+            executed = await statement.executeAsync(params || []);
+          }
+          data = await executed.getAllAsync();
+        } else if (isOPSQLite(driver, db)) {
+          if (arrayMode) {
+            data = await db.executeRaw(sql, params)
+          } else {
+            const statement = db.prepareStatement(sql);
+            if (params) {
+              statement.bind(params);
+            }
+            const executed = await statement.execute()
+            data = executed.rows
+          }
         }
-        const data = await executed.getAllAsync();
-        client.sendMessage(`query-${e.id}`, data);
+
+        client.sendMessage(`query-${id}`, data);
       } catch (error) {
-        client.sendMessage(`query-${e.id}`, { error: error.message });
+        client.sendMessage(`query-${id}`, { error: error.message });
       }
     };
 
   const transactionFn =
-    (db: SQLite.SQLiteDatabase, client: DevToolsPluginClient) =>
-    async (e: { queries: { sql: string; params?: SQLite.SQLiteBindValue[] }[]; id: string }) => {
+    (db: DB | SQLite.SQLiteDatabase, client: DevToolsPluginClient) =>
+    async ({ id, queries }: { queries: { sql: string; params?: SQLite.SQLiteBindValue[] }[]; id: string }) => {
       const results: any[] = [];
       try {
-        await db.withTransactionAsync(async () => {
-          for (const query of e.queries) {
-            const stmt = await db.prepareAsync(query.sql);
-            const executed = await stmt.executeAsync(query.params || []);
-            const result = await executed.getAllAsync();
-            results.push(result);
-          }
-        });
+        if (isExpo(driver, db)) {
+          await db.withTransactionAsync(async () => {
+            for (const query of queries) {
+              const stmt = await db.prepareAsync(query.sql);
+              const executed = await stmt.executeAsync(query.params || []);
+              const result = await executed.getAllAsync();
+              results.push(result);
+            }
+          });
+        } else if (isOPSQLite(driver, db)) {
+          await db.transaction(async (transaction) => {
+            for (const { sql, params } of queries) {
+              const executed = await transaction.execute(sql, params)
+              results.concat(executed.rows)
+            }
+          })
+        }
       } catch (error) {
         results.push({ error: error.message });
       }
-      client.sendMessage(`transaction-${e.id}`, results);
+      client.sendMessage(`transaction-${id}`, results);
     };
 
   useEffect(() => {
